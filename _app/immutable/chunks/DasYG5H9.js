const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./BfN7rNmm.js","./B2c5_Eok.js","./dv0JZMFe.js","./BQaxZROR.js","./CAeRHjNp.js","./BkaqWuDM.js","./AId8NOvR.js","./QwGMLEyr.js","./BGSar6W7.js","./ByRDRQcx.js"])))=>i.map(i=>d[i]);
import{i as ve,t as Te,a as Ee}from"./DXTehwCs.js";import{p as Se,ah as Ae,af as Xt,a as Pe,u as q,ag as De,c as bt,C as Me,r as vt}from"./URlnBa4D.js";import{b as Oe}from"./CWXliKH6.js";import{g as ee,C as Ce,M as Q,V as N,a as j,Q as Ie,b as Ht,c as qt,T as Ue,S as Fe,d as pt,e as ke,P as Ne,O as Re,W as Ge,f as Le,B as je,h as $t,i as Be,j as Ve,k as ze}from"./BGSar6W7.js";import{_ as H}from"./C1FmrZbK.js";import"./B7Q57k1f.js";function A(i){return(t,...e)=>Ke(i,t,e)}function tt(i,t){return A(ie(i,t).get)}const{apply:Ke,getOwnPropertyDescriptor:ie,getPrototypeOf:Ct,ownKeys:Ye}=Reflect,{iterator:at,toStringTag:Ze}=Symbol,Xe=Object,{create:It,defineProperty:He}=Xe,qe=Array,$e=qe.prototype,oe=$e[at],We=A(oe),ne=ArrayBuffer,Qe=ne.prototype;tt(Qe,"byteLength");const Wt=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:null;Wt&&tt(Wt.prototype,"byteLength");const se=Ct(Uint8Array);se.from;const M=se.prototype;M[at];A(M.keys);A(M.values);A(M.entries);A(M.set);A(M.reverse);A(M.fill);A(M.copyWithin);A(M.sort);A(M.slice);A(M.subarray);tt(M,"buffer");tt(M,"byteOffset");tt(M,"length");tt(M,Ze);const Je=Uint8Array,re=Uint16Array,Ut=Uint32Array,ti=Float32Array,rt=Ct([][at]()),ae=A(rt.next),ei=A(function*(){}().next),ii=Ct(rt),oi=DataView.prototype,ni=A(oi.getUint16),Ft=WeakMap,ce=Ft.prototype,le=A(ce.get),si=A(ce.set),he=new Ft,ri=It(null,{next:{value:function(){const t=le(he,this);return ae(t)}},[at]:{value:function(){return this}}});function ai(i){if(i[at]===oe&&rt.next===ae)return i;const t=It(ri);return si(he,t,We(i)),t}const ci=new Ft,li=It(ii,{next:{value:function(){const t=le(ci,this);return ei(t)},writable:!0,configurable:!0}});for(const i of Ye(rt))i!=="next"&&He(li,i,ie(rt,i));const fe=new ne(4),hi=new ti(fe),fi=new Ut(fe),R=new re(512),G=new Je(512);for(let i=0;i<256;++i){const t=i-127;t<-24?(R[i]=0,R[i|256]=32768,G[i]=24,G[i|256]=24):t<-14?(R[i]=1024>>-t-14,R[i|256]=1024>>-t-14|32768,G[i]=-t-1,G[i|256]=-t-1):t<=15?(R[i]=t+15<<10,R[i|256]=t+15<<10|32768,G[i]=13,G[i|256]=13):t<128?(R[i]=31744,R[i|256]=64512,G[i]=24,G[i|256]=24):(R[i]=31744,R[i|256]=64512,G[i]=13,G[i|256]=13)}const kt=new Ut(2048);for(let i=1;i<1024;++i){let t=i<<13,e=0;for(;!(t&8388608);)t<<=1,e-=8388608;t&=-8388609,e+=947912704,kt[i]=t|e}for(let i=1024;i<2048;++i)kt[i]=939524096+(i-1024<<13);const et=new Ut(64);for(let i=1;i<31;++i)et[i]=i<<23;et[31]=1199570944;et[32]=2147483648;for(let i=33;i<63;++i)et[i]=2147483648+(i-32<<23);et[63]=3347054592;const ue=new re(64);for(let i=1;i<64;++i)i!==32&&(ue[i]=1024);function ui(i){const t=i>>10;return fi[0]=kt[ue[t]+(i&1023)]+et[t],hi[0]}function pe(i,t,...e){return ui(ni(i,t,...ai(e)))}var Nt={exports:{}};function de(i,t,e){const n=e&&e.debug||!1;n&&console.log("[xml-utils] getting "+t+" in "+i);const o=typeof i=="object"?i.outer:i,s=o.slice(0,o.indexOf(">")+1),a=['"',"'"];for(let r=0;r<a.length;r++){const c=a[r],l=t+"\\="+c+"([^"+c+"]*)"+c;n&&console.log("[xml-utils] pattern:",l);const h=new RegExp(l).exec(s);if(n&&console.log("[xml-utils] match:",h),h)return h[1]}}Nt.exports=de;Nt.exports.default=de;var pi=Nt.exports;const Tt=ee(pi);var Rt={exports:{}},Gt={exports:{}},Lt={exports:{}};function ge(i,t,e){const o=new RegExp(t).exec(i.slice(e));return o?e+o.index:-1}Lt.exports=ge;Lt.exports.default=ge;var di=Lt.exports,jt={exports:{}};function ye(i,t,e){const o=new RegExp(t).exec(i.slice(e));return o?e+o.index+o[0].length-1:-1}jt.exports=ye;jt.exports.default=ye;var gi=jt.exports,Bt={exports:{}};function me(i,t){const e=new RegExp(t,"g"),n=i.match(e);return n?n.length:0}Bt.exports=me;Bt.exports.default=me;var yi=Bt.exports;const mi=di,Et=gi,Qt=yi;function xe(i,t,e){const n=e&&e.debug||!1,o=!(e&&typeof e.nested===!1),s=e&&e.startIndex||0;n&&console.log("[xml-utils] starting findTagByName with",t," and ",e);const a=mi(i,`<${t}[ 
>/]`,s);if(n&&console.log("[xml-utils] start:",a),a===-1)return;const r=i.slice(a+t.length);let c=Et(r,"^[^<]*[ /]>",0);const l=c!==-1&&r[c-1]==="/";if(n&&console.log("[xml-utils] selfClosing:",l),l===!1)if(o){let u=0,p=1,m=0;for(;(c=Et(r,"[ /]"+t+">",u))!==-1;){const d=r.substring(u,c+1);if(p+=Qt(d,"<"+t+`[ 
	>]`),m+=Qt(d,"</"+t+">"),m>=p)break;u=c}}else c=Et(r,"[ /]"+t+">",0);const f=a+t.length+c+1;if(n&&console.log("[xml-utils] end:",f),f===-1)return;const h=i.slice(a,f);let y;return l?y=null:y=h.slice(h.indexOf(">")+1,h.lastIndexOf("<")),{inner:y,outer:h,start:a,end:f}}Gt.exports=xe;Gt.exports.default=xe;var xi=Gt.exports;const _i=xi;function _e(i,t,e){const n=[],o=e&&e.debug||!1,s=e&&typeof e.nested=="boolean"?e.nested:!0;let a=e&&e.startIndex||0,r;for(;r=_i(i,t,{debug:o,startIndex:a});)s?a=r.start+1+t.length:a=r.end,n.push(r);return o&&console.log("findTagsByName found",n.length,"tags"),n}Rt.exports=_e;Rt.exports.default=_e;var wi=Rt.exports;const bi=ee(wi),st={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},L={};for(const i in st)st.hasOwnProperty(i)&&(L[st[i]]=parseInt(i,10));const vi=[L.BitsPerSample,L.ExtraSamples,L.SampleFormat,L.StripByteCounts,L.StripOffsets,L.StripRowCounts,L.TileByteCounts,L.TileOffsets,L.SubIFDs],St={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},x={};for(const i in St)St.hasOwnProperty(i)&&(x[St[i]]=parseInt(i,10));const C={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,CMYK:5,YCbCr:6,CIELab:8},Ti={Unspecified:0},Ao={AddCompression:1},Po={None:0,Deflate:1,Zstandard:2},Ei={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"};function Si(i,t){const{width:e,height:n}=i,o=new Uint8Array(e*n*3);let s;for(let a=0,r=0;a<i.length;++a,r+=3)s=256-i[a]/t*256,o[r]=s,o[r+1]=s,o[r+2]=s;return o}function Ai(i,t){const{width:e,height:n}=i,o=new Uint8Array(e*n*3);let s;for(let a=0,r=0;a<i.length;++a,r+=3)s=i[a]/t*256,o[r]=s,o[r+1]=s,o[r+2]=s;return o}function Pi(i,t){const{width:e,height:n}=i,o=new Uint8Array(e*n*3),s=t.length/3,a=t.length/3*2;for(let r=0,c=0;r<i.length;++r,c+=3){const l=i[r];o[c]=t[l]/65536*256,o[c+1]=t[l+s]/65536*256,o[c+2]=t[l+a]/65536*256}return o}function Di(i){const{width:t,height:e}=i,n=new Uint8Array(t*e*3);for(let o=0,s=0;o<i.length;o+=4,s+=3){const a=i[o],r=i[o+1],c=i[o+2],l=i[o+3];n[s]=255*((255-a)/256)*((255-l)/256),n[s+1]=255*((255-r)/256)*((255-l)/256),n[s+2]=255*((255-c)/256)*((255-l)/256)}return n}function Mi(i){const{width:t,height:e}=i,n=new Uint8ClampedArray(t*e*3);for(let o=0,s=0;o<i.length;o+=3,s+=3){const a=i[o],r=i[o+1],c=i[o+2];n[s]=a+1.402*(c-128),n[s+1]=a-.34414*(r-128)-.71414*(c-128),n[s+2]=a+1.772*(r-128)}return n}const Oi=.95047,Ci=1,Ii=1.08883;function Ui(i){const{width:t,height:e}=i,n=new Uint8Array(t*e*3);for(let o=0,s=0;o<i.length;o+=3,s+=3){const a=i[o+0],r=i[o+1]<<24>>24,c=i[o+2]<<24>>24;let l=(a+16)/116,f=r/500+l,h=l-c/200,y,u,p;f=Oi*(f*f*f>.008856?f*f*f:(f-16/116)/7.787),l=Ci*(l*l*l>.008856?l*l*l:(l-16/116)/7.787),h=Ii*(h*h*h>.008856?h*h*h:(h-16/116)/7.787),y=f*3.2406+l*-1.5372+h*-.4986,u=f*-.9689+l*1.8758+h*.0415,p=f*.0557+l*-.204+h*1.057,y=y>.0031308?1.055*y**(1/2.4)-.055:12.92*y,u=u>.0031308?1.055*u**(1/2.4)-.055:12.92*u,p=p>.0031308?1.055*p**(1/2.4)-.055:12.92*p,n[s]=Math.max(0,Math.min(1,y))*255,n[s+1]=Math.max(0,Math.min(1,u))*255,n[s+2]=Math.max(0,Math.min(1,p))*255}return n}const we=new Map;function V(i,t){Array.isArray(i)||(i=[i]),i.forEach(e=>we.set(e,t))}async function Fi(i){const t=we.get(i.Compression);if(!t)throw new Error(`Unknown compression method identifier: ${i.Compression}`);const e=await t();return new e(i)}V([void 0,1],()=>H(()=>import("./BfN7rNmm.js"),__vite__mapDeps([0,1]),import.meta.url).then(i=>i.default));V(5,()=>H(()=>import("./dv0JZMFe.js"),__vite__mapDeps([2,1]),import.meta.url).then(i=>i.default));V(6,()=>{throw new Error("old style JPEG compression is not supported.")});V(7,()=>H(()=>import("./BQaxZROR.js"),__vite__mapDeps([3,1]),import.meta.url).then(i=>i.default));V([8,32946],()=>H(()=>import("./CAeRHjNp.js"),__vite__mapDeps([4,5,1]),import.meta.url).then(i=>i.default));V(32773,()=>H(()=>import("./AId8NOvR.js"),__vite__mapDeps([6,1]),import.meta.url).then(i=>i.default));V(34887,()=>H(()=>import("./QwGMLEyr.js"),__vite__mapDeps([7,5,8,1]),import.meta.url).then(async i=>(await i.zstd.init(),i)).then(i=>i.default));V(50001,()=>H(()=>import("./ByRDRQcx.js"),__vite__mapDeps([9,1]),import.meta.url).then(i=>i.default));function _t(i,t,e,n=1){return new(Object.getPrototypeOf(i)).constructor(t*e*n)}function ki(i,t,e,n,o){const s=t/n,a=e/o;return i.map(r=>{const c=_t(r,n,o);for(let l=0;l<o;++l){const f=Math.min(Math.round(a*l),e-1);for(let h=0;h<n;++h){const y=Math.min(Math.round(s*h),t-1),u=r[f*t+y];c[l*n+h]=u}}return c})}function J(i,t,e){return(1-e)*i+e*t}function Ni(i,t,e,n,o){const s=t/n,a=e/o;return i.map(r=>{const c=_t(r,n,o);for(let l=0;l<o;++l){const f=a*l,h=Math.floor(f),y=Math.min(Math.ceil(f),e-1);for(let u=0;u<n;++u){const p=s*u,m=p%1,d=Math.floor(p),T=Math.min(Math.ceil(p),t-1),g=r[h*t+d],E=r[h*t+T],b=r[y*t+d],_=r[y*t+T],v=J(J(g,E,m),J(b,_,m),f%1);c[l*n+u]=v}}return c})}function Ri(i,t,e,n,o,s="nearest"){switch(s.toLowerCase()){case"nearest":return ki(i,t,e,n,o);case"bilinear":case"linear":return Ni(i,t,e,n,o);default:throw new Error(`Unsupported resampling method: '${s}'`)}}function Gi(i,t,e,n,o,s){const a=t/n,r=e/o,c=_t(i,n,o,s);for(let l=0;l<o;++l){const f=Math.min(Math.round(r*l),e-1);for(let h=0;h<n;++h){const y=Math.min(Math.round(a*h),t-1);for(let u=0;u<s;++u){const p=i[f*t*s+y*s+u];c[l*n*s+h*s+u]=p}}}return c}function Li(i,t,e,n,o,s){const a=t/n,r=e/o,c=_t(i,n,o,s);for(let l=0;l<o;++l){const f=r*l,h=Math.floor(f),y=Math.min(Math.ceil(f),e-1);for(let u=0;u<n;++u){const p=a*u,m=p%1,d=Math.floor(p),T=Math.min(Math.ceil(p),t-1);for(let g=0;g<s;++g){const E=i[h*t*s+d*s+g],b=i[h*t*s+T*s+g],_=i[y*t*s+d*s+g],v=i[y*t*s+T*s+g],D=J(J(E,b,m),J(_,v,m),f%1);c[l*n*s+u*s+g]=D}}}return c}function ji(i,t,e,n,o,s,a="nearest"){switch(a.toLowerCase()){case"nearest":return Gi(i,t,e,n,o,s);case"bilinear":case"linear":return Li(i,t,e,n,o,s);default:throw new Error(`Unsupported resampling method: '${a}'`)}}function Bi(i,t,e){let n=0;for(let o=t;o<e;++o)n+=i[o];return n}function Mt(i,t,e){switch(i){case 1:if(t<=8)return new Uint8Array(e);if(t<=16)return new Uint16Array(e);if(t<=32)return new Uint32Array(e);break;case 2:if(t===8)return new Int8Array(e);if(t===16)return new Int16Array(e);if(t===32)return new Int32Array(e);break;case 3:switch(t){case 16:case 32:return new Float32Array(e);case 64:return new Float64Array(e)}break}throw Error("Unsupported data format/bitsPerSample")}function Vi(i,t){return(i===1||i===2)&&t<=32&&t%8===0?!1:!(i===3&&(t===16||t===32||t===64))}function zi(i,t,e,n,o,s,a){const r=new DataView(i),c=e===2?a*s:a*s*n,l=e===2?1:n,f=Mt(t,o,c),h=parseInt("1".repeat(o),2);if(t===1){let y;e===1?y=n*o:y=o;let u=s*y;u&7&&(u=u+7&-8);for(let p=0;p<a;++p){const m=p*u;for(let d=0;d<s;++d){const T=m+d*l*o;for(let g=0;g<l;++g){const E=T+g*o,b=(p*s+d)*l+g,_=Math.floor(E/8),v=E%8;if(v+o<=8)f[b]=r.getUint8(_)>>8-o-v&h;else if(v+o<=16)f[b]=r.getUint16(_)>>16-o-v&h;else if(v+o<=24){const D=r.getUint16(_)<<8|r.getUint8(_+2);f[b]=D>>24-o-v&h}else f[b]=r.getUint32(_)>>32-o-v&h}}}}return f.buffer}class Ki{constructor(t,e,n,o,s,a){this.fileDirectory=t,this.geoKeys=e,this.dataView=n,this.littleEndian=o,this.tiles=s?{}:null,this.isTiled=!t.StripOffsets;const r=t.PlanarConfiguration;if(this.planarConfiguration=typeof r>"u"?1:r,this.planarConfiguration!==1&&this.planarConfiguration!==2)throw new Error("Invalid planar configuration.");this.source=a}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return typeof this.fileDirectory.SamplesPerPixel<"u"?this.fileDirectory.SamplesPerPixel:1}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:typeof this.fileDirectory.RowsPerStrip<"u"?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBlockWidth(){return this.getTileWidth()}getBlockHeight(t){return this.isTiled||(t+1)*this.getTileHeight()<=this.getHeight()?this.getTileHeight():this.getHeight()-t*this.getTileHeight()}getBytesPerPixel(){let t=0;for(let e=0;e<this.fileDirectory.BitsPerSample.length;++e)t+=this.getSampleByteSize(e);return t}getSampleByteSize(t){if(t>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${t} is out of range.`);return Math.ceil(this.fileDirectory.BitsPerSample[t]/8)}getReaderForSample(t){const e=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[t]:1,n=this.fileDirectory.BitsPerSample[t];switch(e){case 1:if(n<=8)return DataView.prototype.getUint8;if(n<=16)return DataView.prototype.getUint16;if(n<=32)return DataView.prototype.getUint32;break;case 2:if(n<=8)return DataView.prototype.getInt8;if(n<=16)return DataView.prototype.getInt16;if(n<=32)return DataView.prototype.getInt32;break;case 3:switch(n){case 16:return function(o,s){return pe(this,o,s)};case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64}break}throw Error("Unsupported data format/bitsPerSample")}getSampleFormat(t=0){return this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[t]:1}getBitsPerSample(t=0){return this.fileDirectory.BitsPerSample[t]}getArrayForSample(t,e){const n=this.getSampleFormat(t),o=this.getBitsPerSample(t);return Mt(n,o,e)}async getTileOrStrip(t,e,n,o,s){const a=Math.ceil(this.getWidth()/this.getTileWidth()),r=Math.ceil(this.getHeight()/this.getTileHeight());let c;const{tiles:l}=this;this.planarConfiguration===1?c=e*a+t:this.planarConfiguration===2&&(c=n*a*r+e*a+t);let f,h;this.isTiled?(f=this.fileDirectory.TileOffsets[c],h=this.fileDirectory.TileByteCounts[c]):(f=this.fileDirectory.StripOffsets[c],h=this.fileDirectory.StripByteCounts[c]);const y=(await this.source.fetch([{offset:f,length:h}],s))[0];let u;return l===null||!l[c]?(u=(async()=>{let p=await o.decode(this.fileDirectory,y);const m=this.getSampleFormat(),d=this.getBitsPerSample();return Vi(m,d)&&(p=zi(p,m,this.planarConfiguration,this.getSamplesPerPixel(),d,this.getTileWidth(),this.getBlockHeight(e))),p})(),l!==null&&(l[c]=u)):u=l[c],{x:t,y:e,sample:n,data:await u}}async _readRaster(t,e,n,o,s,a,r,c,l){const f=this.getTileWidth(),h=this.getTileHeight(),y=this.getWidth(),u=this.getHeight(),p=Math.max(Math.floor(t[0]/f),0),m=Math.min(Math.ceil(t[2]/f),Math.ceil(y/f)),d=Math.max(Math.floor(t[1]/h),0),T=Math.min(Math.ceil(t[3]/h),Math.ceil(u/h)),g=t[2]-t[0];let E=this.getBytesPerPixel();const b=[],_=[];for(let w=0;w<e.length;++w)this.planarConfiguration===1?b.push(Bi(this.fileDirectory.BitsPerSample,0,e[w])/8):b.push(0),_.push(this.getReaderForSample(e[w]));const v=[],{littleEndian:D}=this;for(let w=d;w<T;++w)for(let I=p;I<m;++I){let U;this.planarConfiguration===1&&(U=this.getTileOrStrip(I,w,0,s,l));for(let k=0;k<e.length;++k){const O=k,ct=e[k];this.planarConfiguration===2&&(E=this.getSampleByteSize(ct),U=this.getTileOrStrip(I,w,ct,s,l));const wt=U.then(z=>{const lt=z.data,ht=new DataView(lt),it=this.getBlockHeight(z.y),F=z.y*h,P=z.x*f,K=F+it,ot=(z.x+1)*f,Y=_[O],Z=Math.min(it,it-(K-t[3]),u-F),ft=Math.min(f,f-(ot-t[2]),y-P);for(let X=Math.max(0,t[1]-F);X<Z;++X)for(let nt=Math.max(0,t[0]-P);nt<ft;++nt){const be=(X*f+nt)*E,Zt=Y.call(ht,be+b[O],D);let ut;o?(ut=(X+F-t[1])*g*e.length+(nt+P-t[0])*e.length+O,n[ut]=Zt):(ut=(X+F-t[1])*g+nt+P-t[0],n[O][ut]=Zt)}});v.push(wt)}}if(await Promise.all(v),a&&t[2]-t[0]!==a||r&&t[3]-t[1]!==r){let w;return o?w=ji(n,t[2]-t[0],t[3]-t[1],a,r,e.length,c):w=Ri(n,t[2]-t[0],t[3]-t[1],a,r,c),w.width=a,w.height=r,w}return n.width=a||t[2]-t[0],n.height=r||t[3]-t[1],n}async readRasters({window:t,samples:e=[],interleave:n,pool:o=null,width:s,height:a,resampleMethod:r,fillValue:c,signal:l}={}){const f=t||[0,0,this.getWidth(),this.getHeight()];if(f[0]>f[2]||f[1]>f[3])throw new Error("Invalid subsets");const h=f[2]-f[0],y=f[3]-f[1],u=h*y,p=this.getSamplesPerPixel();if(!e||!e.length)for(let g=0;g<p;++g)e.push(g);else for(let g=0;g<e.length;++g)if(e[g]>=p)return Promise.reject(new RangeError(`Invalid sample index '${e[g]}'.`));let m;if(n){const g=this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,E=Math.max.apply(null,this.fileDirectory.BitsPerSample);m=Mt(g,E,u*e.length),c&&m.fill(c)}else{m=[];for(let g=0;g<e.length;++g){const E=this.getArrayForSample(e[g],u);Array.isArray(c)&&g<c.length?E.fill(c[g]):c&&!Array.isArray(c)&&E.fill(c),m.push(E)}}const d=o||await Fi(this.fileDirectory);return await this._readRaster(f,e,m,n,d,s,a,r,l)}async readRGB({window:t,interleave:e=!0,pool:n=null,width:o,height:s,resampleMethod:a,enableAlpha:r=!1,signal:c}={}){const l=t||[0,0,this.getWidth(),this.getHeight()];if(l[0]>l[2]||l[1]>l[3])throw new Error("Invalid subsets");const f=this.fileDirectory.PhotometricInterpretation;if(f===C.RGB){let T=[0,1,2];if(this.fileDirectory.ExtraSamples!==Ti.Unspecified&&r){T=[];for(let g=0;g<this.fileDirectory.BitsPerSample.length;g+=1)T.push(g)}return this.readRasters({window:t,interleave:e,samples:T,pool:n,width:o,height:s,resampleMethod:a,signal:c})}let h;switch(f){case C.WhiteIsZero:case C.BlackIsZero:case C.Palette:h=[0];break;case C.CMYK:h=[0,1,2,3];break;case C.YCbCr:case C.CIELab:h=[0,1,2];break;default:throw new Error("Invalid or unsupported photometric interpretation.")}const y={window:l,interleave:!0,samples:h,pool:n,width:o,height:s,resampleMethod:a,signal:c},{fileDirectory:u}=this,p=await this.readRasters(y),m=2**this.fileDirectory.BitsPerSample[0];let d;switch(f){case C.WhiteIsZero:d=Si(p,m);break;case C.BlackIsZero:d=Ai(p,m);break;case C.Palette:d=Pi(p,u.ColorMap);break;case C.CMYK:d=Di(p);break;case C.YCbCr:d=Mi(p);break;case C.CIELab:d=Ui(p);break;default:throw new Error("Unsupported photometric interpretation.")}if(!e){const T=new Uint8Array(d.length/3),g=new Uint8Array(d.length/3),E=new Uint8Array(d.length/3);for(let b=0,_=0;b<d.length;b+=3,++_)T[_]=d[b],g[_]=d[b+1],E[_]=d[b+2];d=[T,g,E]}return d.width=p.width,d.height=p.height,d}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const t=[];for(let e=0;e<this.fileDirectory.ModelTiepoint.length;e+=6)t.push({i:this.fileDirectory.ModelTiepoint[e],j:this.fileDirectory.ModelTiepoint[e+1],k:this.fileDirectory.ModelTiepoint[e+2],x:this.fileDirectory.ModelTiepoint[e+3],y:this.fileDirectory.ModelTiepoint[e+4],z:this.fileDirectory.ModelTiepoint[e+5]});return t}getGDALMetadata(t=null){const e={};if(!this.fileDirectory.GDAL_METADATA)return null;const n=this.fileDirectory.GDAL_METADATA;let o=bi(n,"Item");t===null?o=o.filter(s=>Tt(s,"sample")===void 0):o=o.filter(s=>Number(Tt(s,"sample"))===t);for(let s=0;s<o.length;++s){const a=o[s];e[Tt(a,"name")]=a.inner}return e}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const t=this.fileDirectory.GDAL_NODATA;return Number(t.substring(0,t.length-1))}getOrigin(){const t=this.fileDirectory.ModelTiepoint,e=this.fileDirectory.ModelTransformation;if(t&&t.length===6)return[t[3],t[4],t[5]];if(e)return[e[3],e[7],e[11]];throw new Error("The image does not have an affine transformation.")}getResolution(t=null){const e=this.fileDirectory.ModelPixelScale,n=this.fileDirectory.ModelTransformation;if(e)return[e[0],-e[1],e[2]];if(n)return n[1]===0&&n[4]===0?[n[0],-n[5],n[10]]:[Math.sqrt(n[0]*n[0]+n[4]*n[4]),-Math.sqrt(n[1]*n[1]+n[5]*n[5]),n[10]];if(t){const[o,s,a]=t.getResolution();return[o*t.getWidth()/this.getWidth(),s*t.getHeight()/this.getHeight(),a*t.getWidth()/this.getWidth()]}throw new Error("The image does not have an affine transformation.")}pixelIsArea(){return this.geoKeys.GTRasterTypeGeoKey===1}getBoundingBox(t=!1){const e=this.getHeight(),n=this.getWidth();if(this.fileDirectory.ModelTransformation&&!t){const[o,s,a,r,c,l,f,h]=this.fileDirectory.ModelTransformation,u=[[0,0],[0,e],[n,0],[n,e]].map(([d,T])=>[r+o*d+s*T,h+c*d+l*T]),p=u.map(d=>d[0]),m=u.map(d=>d[1]);return[Math.min(...p),Math.min(...m),Math.max(...p),Math.max(...m)]}else{const o=this.getOrigin(),s=this.getResolution(),a=o[0],r=o[1],c=a+s[0]*n,l=r+s[1]*e;return[Math.min(a,c),Math.min(r,l),Math.max(a,c),Math.max(r,l)]}}}class Yi{constructor(t){this._dataView=new DataView(t)}get buffer(){return this._dataView.buffer}getUint64(t,e){const n=this.getUint32(t,e),o=this.getUint32(t+4,e);let s;if(e){if(s=n+2**32*o,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}if(s=2**32*n+o,!Number.isSafeInteger(s))throw new Error(`${s} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return s}getInt64(t,e){let n=0;const o=(this._dataView.getUint8(t+(e?7:0))&128)>0;let s=!0;for(let a=0;a<8;a++){let r=this._dataView.getUint8(t+(e?a:7-a));o&&(s?r!==0&&(r=~(r-1)&255,s=!1):r=~r&255),n+=r*256**a}return o&&(n=-n),n}getUint8(t,e){return this._dataView.getUint8(t,e)}getInt8(t,e){return this._dataView.getInt8(t,e)}getUint16(t,e){return this._dataView.getUint16(t,e)}getInt16(t,e){return this._dataView.getInt16(t,e)}getUint32(t,e){return this._dataView.getUint32(t,e)}getInt32(t,e){return this._dataView.getInt32(t,e)}getFloat16(t,e){return pe(this._dataView,t,e)}getFloat32(t,e){return this._dataView.getFloat32(t,e)}getFloat64(t,e){return this._dataView.getFloat64(t,e)}}class Zi{constructor(t,e,n,o){this._dataView=new DataView(t),this._sliceOffset=e,this._littleEndian=n,this._bigTiff=o}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(t,e){return this.sliceOffset<=t&&this.sliceTop>=t+e}readUint8(t){return this._dataView.getUint8(t-this._sliceOffset,this._littleEndian)}readInt8(t){return this._dataView.getInt8(t-this._sliceOffset,this._littleEndian)}readUint16(t){return this._dataView.getUint16(t-this._sliceOffset,this._littleEndian)}readInt16(t){return this._dataView.getInt16(t-this._sliceOffset,this._littleEndian)}readUint32(t){return this._dataView.getUint32(t-this._sliceOffset,this._littleEndian)}readInt32(t){return this._dataView.getInt32(t-this._sliceOffset,this._littleEndian)}readFloat32(t){return this._dataView.getFloat32(t-this._sliceOffset,this._littleEndian)}readFloat64(t){return this._dataView.getFloat64(t-this._sliceOffset,this._littleEndian)}readUint64(t){const e=this.readUint32(t),n=this.readUint32(t+4);let o;if(this._littleEndian){if(o=e+2**32*n,!Number.isSafeInteger(o))throw new Error(`${o} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return o}if(o=2**32*e+n,!Number.isSafeInteger(o))throw new Error(`${o} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return o}readInt64(t){let e=0;const n=(this._dataView.getUint8(t+(this._littleEndian?7:0))&128)>0;let o=!0;for(let s=0;s<8;s++){let a=this._dataView.getUint8(t+(this._littleEndian?s:7-s));n&&(o?a!==0&&(a=~(a-1)&255,o=!1):a=~a&255),e+=a*256**s}return n&&(e=-e),e}readOffset(t){return this._bigTiff?this.readUint64(t):this.readUint32(t)}}class Xi{async fetch(t,e=void 0){return Promise.all(t.map(n=>this.fetchSlice(n,e)))}async fetchSlice(t){throw new Error(`fetching of slice ${t} not possible, not implemented`)}get fileSize(){return null}async close(){}}class Vt extends Error{constructor(t){super(t),Error.captureStackTrace&&Error.captureStackTrace(this,Vt),this.name="AbortError"}}class Hi extends Xi{constructor(t){super(),this.arrayBuffer=t}fetchSlice(t,e){if(e&&e.aborted)throw new Vt("Request aborted");return this.arrayBuffer.slice(t.offset,t.offset+t.length)}}function qi(i){return new Hi(i)}function Ot(i){switch(i){case x.BYTE:case x.ASCII:case x.SBYTE:case x.UNDEFINED:return 1;case x.SHORT:case x.SSHORT:return 2;case x.LONG:case x.SLONG:case x.FLOAT:case x.IFD:return 4;case x.RATIONAL:case x.SRATIONAL:case x.DOUBLE:case x.LONG8:case x.SLONG8:case x.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${i}`)}}function $i(i){const t=i.GeoKeyDirectory;if(!t)return null;const e={};for(let n=4;n<=t[3]*4;n+=4){const o=Ei[t[n]],s=t[n+1]?st[t[n+1]]:null,a=t[n+2],r=t[n+3];let c=null;if(!s)c=r;else{if(c=i[s],typeof c>"u"||c===null)throw new Error(`Could not get value of geoKey '${o}'.`);typeof c=="string"?c=c.substring(r,r+a-1):c.subarray&&(c=c.subarray(r,r+a),a===1&&(c=c[0]))}e[o]=c}return e}function $(i,t,e,n){let o=null,s=null;const a=Ot(t);switch(t){case x.BYTE:case x.ASCII:case x.UNDEFINED:o=new Uint8Array(e),s=i.readUint8;break;case x.SBYTE:o=new Int8Array(e),s=i.readInt8;break;case x.SHORT:o=new Uint16Array(e),s=i.readUint16;break;case x.SSHORT:o=new Int16Array(e),s=i.readInt16;break;case x.LONG:case x.IFD:o=new Uint32Array(e),s=i.readUint32;break;case x.SLONG:o=new Int32Array(e),s=i.readInt32;break;case x.LONG8:case x.IFD8:o=new Array(e),s=i.readUint64;break;case x.SLONG8:o=new Array(e),s=i.readInt64;break;case x.RATIONAL:o=new Uint32Array(e*2),s=i.readUint32;break;case x.SRATIONAL:o=new Int32Array(e*2),s=i.readInt32;break;case x.FLOAT:o=new Float32Array(e),s=i.readFloat32;break;case x.DOUBLE:o=new Float64Array(e),s=i.readFloat64;break;default:throw new RangeError(`Invalid field type: ${t}`)}if(t===x.RATIONAL||t===x.SRATIONAL)for(let r=0;r<e;r+=2)o[r]=s.call(i,n+r*a),o[r+1]=s.call(i,n+(r*a+4));else for(let r=0;r<e;++r)o[r]=s.call(i,n+r*a);return t===x.ASCII?new TextDecoder("utf-8").decode(o):o}class Wi{constructor(t,e,n){this.fileDirectory=t,this.geoKeyDirectory=e,this.nextIFDByteOffset=n}}class dt extends Error{constructor(t){super(`No image at index ${t}`),this.index=t}}class Qi{async readRasters(t={}){const{window:e,width:n,height:o}=t;let{resX:s,resY:a,bbox:r}=t;const c=await this.getImage();let l=c;const f=await this.getImageCount(),h=c.getBoundingBox();if(e&&r)throw new Error('Both "bbox" and "window" passed.');if(n||o){if(e){const[p,m]=c.getOrigin(),[d,T]=c.getResolution();r=[p+e[0]*d,m+e[1]*T,p+e[2]*d,m+e[3]*T]}const u=r||h;if(n){if(s)throw new Error("Both width and resX passed");s=(u[2]-u[0])/n}if(o){if(a)throw new Error("Both width and resY passed");a=(u[3]-u[1])/o}}if(s||a){const u=[];for(let p=0;p<f;++p){const m=await this.getImage(p),{SubfileType:d,NewSubfileType:T}=m.fileDirectory;(p===0||d===2||T&1)&&u.push(m)}u.sort((p,m)=>p.getWidth()-m.getWidth());for(let p=0;p<u.length;++p){const m=u[p],d=(h[2]-h[0])/m.getWidth(),T=(h[3]-h[1])/m.getHeight();if(l=m,s&&s>d||a&&a>T)break}}let y=e;if(r){const[u,p]=c.getOrigin(),[m,d]=l.getResolution(c);y=[Math.round((r[0]-u)/m),Math.round((r[1]-p)/d),Math.round((r[2]-u)/m),Math.round((r[3]-p)/d)],y=[Math.min(y[0],y[2]),Math.min(y[1],y[3]),Math.max(y[0],y[2]),Math.max(y[1],y[3])]}return l.readRasters({...t,window:y})}}class zt extends Qi{constructor(t,e,n,o,s={}){super(),this.source=t,this.littleEndian=e,this.bigTiff=n,this.firstIFDOffset=o,this.cache=s.cache||!1,this.ifdRequests=[],this.ghostValues=null}async getSlice(t,e){const n=this.bigTiff?4048:1024;return new Zi((await this.source.fetch([{offset:t,length:typeof e<"u"?e:n}]))[0],t,this.littleEndian,this.bigTiff)}async parseFileDirectoryAt(t){const e=this.bigTiff?20:12,n=this.bigTiff?8:2;let o=await this.getSlice(t);const s=this.bigTiff?o.readUint64(t):o.readUint16(t),a=s*e+(this.bigTiff?16:6);o.covers(t,a)||(o=await this.getSlice(t,a));const r={};let c=t+(this.bigTiff?8:2);for(let h=0;h<s;c+=e,++h){const y=o.readUint16(c),u=o.readUint16(c+2),p=this.bigTiff?o.readUint64(c+4):o.readUint32(c+4);let m,d;const T=Ot(u),g=c+(this.bigTiff?12:8);if(T*p<=(this.bigTiff?8:4))m=$(o,u,p,g);else{const E=o.readOffset(g),b=Ot(u)*p;if(o.covers(E,b))m=$(o,u,p,E);else{const _=await this.getSlice(E,b);m=$(_,u,p,E)}}p===1&&vi.indexOf(y)===-1&&!(u===x.RATIONAL||u===x.SRATIONAL)?d=m[0]:d=m,r[st[y]]=d}const l=$i(r),f=o.readOffset(t+n+e*s);return new Wi(r,l,f)}async requestIFD(t){if(this.ifdRequests[t])return this.ifdRequests[t];if(t===0)return this.ifdRequests[t]=this.parseFileDirectoryAt(this.firstIFDOffset),this.ifdRequests[t];if(!this.ifdRequests[t-1])try{this.ifdRequests[t-1]=this.requestIFD(t-1)}catch(e){throw e instanceof dt?new dt(t):e}return this.ifdRequests[t]=(async()=>{const e=await this.ifdRequests[t-1];if(e.nextIFDByteOffset===0)throw new dt(t);return this.parseFileDirectoryAt(e.nextIFDByteOffset)})(),this.ifdRequests[t]}async getImage(t=0){const e=await this.requestIFD(t);return new Ki(e.fileDirectory,e.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){let t=0,e=!0;for(;e;)try{await this.requestIFD(t),++t}catch(n){if(n instanceof dt)e=!1;else throw n}return t}async getGhostValues(){const t=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const e="GDAL_STRUCTURAL_METADATA_SIZE=",n=e.length+100;let o=await this.getSlice(t,n);if(e===$(o,x.ASCII,e.length,t)){const a=$(o,x.ASCII,n,t).split(`
`)[0],r=Number(a.split("=")[1].split(" ")[0])+a.length;r>n&&(o=await this.getSlice(t,r));const c=$(o,x.ASCII,r,t);this.ghostValues={},c.split(`
`).filter(l=>l.length>0).map(l=>l.split("=")).forEach(([l,f])=>{this.ghostValues[l]=f})}return this.ghostValues}static async fromSource(t,e,n){const o=(await t.fetch([{offset:0,length:1024}],n))[0],s=new Yi(o),a=s.getUint16(0,0);let r;if(a===18761)r=!0;else if(a===19789)r=!1;else throw new TypeError("Invalid byte order value.");const c=s.getUint16(2,r);let l;if(c===42)l=!1;else if(c===43){if(l=!0,s.getUint16(4,r)!==8)throw new Error("Unsupported offset byte-size.")}else throw new TypeError("Invalid magic number.");const f=l?s.getUint64(8,r):s.getUint32(4,r);return new zt(t,r,l,f,e)}close(){return typeof this.source.close=="function"?this.source.close():!1}}async function Ji(i,t){return zt.fromSource(qi(i),t)}const At={type:"change"},Kt={type:"start"},Yt={type:"end"},Jt=1e-6,S={NONE:-1,ROTATE:0,ZOOM:1,PAN:2,TOUCH_ROTATE:3,TOUCH_ZOOM_PAN:4},gt=new j,B=new j,to=new N,yt=new N,Pt=new N,W=new Ie,te=new N,mt=new N,Dt=new N,xt=new N;class eo extends Ce{constructor(t,e=null){super(t,e),this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.keys=["KeyA","KeyS","KeyD"],this.mouseButtons={LEFT:Q.ROTATE,MIDDLE:Q.DOLLY,RIGHT:Q.PAN},this.state=S.NONE,this.keyState=S.NONE,this.target=new N,this._lastPosition=new N,this._lastZoom=1,this._touchZoomDistanceStart=0,this._touchZoomDistanceEnd=0,this._lastAngle=0,this._eye=new N,this._movePrev=new j,this._moveCurr=new j,this._lastAxis=new N,this._zoomStart=new j,this._zoomEnd=new j,this._panStart=new j,this._panEnd=new j,this._pointers=[],this._pointerPositions={},this._onPointerMove=oo.bind(this),this._onPointerDown=io.bind(this),this._onPointerUp=no.bind(this),this._onPointerCancel=so.bind(this),this._onContextMenu=uo.bind(this),this._onMouseWheel=fo.bind(this),this._onKeyDown=ao.bind(this),this._onKeyUp=ro.bind(this),this._onTouchStart=po.bind(this),this._onTouchMove=go.bind(this),this._onTouchEnd=yo.bind(this),this._onMouseDown=co.bind(this),this._onMouseMove=lo.bind(this),this._onMouseUp=ho.bind(this),this._target0=this.target.clone(),this._position0=this.object.position.clone(),this._up0=this.object.up.clone(),this._zoom0=this.object.zoom,e!==null&&(this.connect(),this.handleResize()),this.update()}connect(){window.addEventListener("keydown",this._onKeyDown),window.addEventListener("keyup",this._onKeyUp),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerCancel),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.style.touchAction="none"}disconnect(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp),this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerCancel),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}handleResize(){const t=this.domElement.getBoundingClientRect(),e=this.domElement.ownerDocument.documentElement;this.screen.left=t.left+window.pageXOffset-e.clientLeft,this.screen.top=t.top+window.pageYOffset-e.clientTop,this.screen.width=t.width,this.screen.height=t.height}update(){this._eye.subVectors(this.object.position,this.target),this.noRotate||this._rotateCamera(),this.noZoom||this._zoomCamera(),this.noPan||this._panCamera(),this.object.position.addVectors(this.target,this._eye),this.object.isPerspectiveCamera?(this._checkDistances(),this.object.lookAt(this.target),this._lastPosition.distanceToSquared(this.object.position)>Jt&&(this.dispatchEvent(At),this._lastPosition.copy(this.object.position))):this.object.isOrthographicCamera?(this.object.lookAt(this.target),(this._lastPosition.distanceToSquared(this.object.position)>Jt||this._lastZoom!==this.object.zoom)&&(this.dispatchEvent(At),this._lastPosition.copy(this.object.position),this._lastZoom=this.object.zoom)):console.warn("THREE.TrackballControls: Unsupported camera type.")}reset(){this.state=S.NONE,this.keyState=S.NONE,this.target.copy(this._target0),this.object.position.copy(this._position0),this.object.up.copy(this._up0),this.object.zoom=this._zoom0,this.object.updateProjectionMatrix(),this._eye.subVectors(this.object.position,this.target),this.object.lookAt(this.target),this.dispatchEvent(At),this._lastPosition.copy(this.object.position),this._lastZoom=this.object.zoom}_panCamera(){if(B.copy(this._panEnd).sub(this._panStart),B.lengthSq()){if(this.object.isOrthographicCamera){const t=(this.object.right-this.object.left)/this.object.zoom/this.domElement.clientWidth,e=(this.object.top-this.object.bottom)/this.object.zoom/this.domElement.clientWidth;B.x*=t,B.y*=e}B.multiplyScalar(this._eye.length()*this.panSpeed),yt.copy(this._eye).cross(this.object.up).setLength(B.x),yt.add(to.copy(this.object.up).setLength(B.y)),this.object.position.add(yt),this.target.add(yt),this.staticMoving?this._panStart.copy(this._panEnd):this._panStart.add(B.subVectors(this._panEnd,this._panStart).multiplyScalar(this.dynamicDampingFactor))}}_rotateCamera(){xt.set(this._moveCurr.x-this._movePrev.x,this._moveCurr.y-this._movePrev.y,0);let t=xt.length();t?(this._eye.copy(this.object.position).sub(this.target),te.copy(this._eye).normalize(),mt.copy(this.object.up).normalize(),Dt.crossVectors(mt,te).normalize(),mt.setLength(this._moveCurr.y-this._movePrev.y),Dt.setLength(this._moveCurr.x-this._movePrev.x),xt.copy(mt.add(Dt)),Pt.crossVectors(xt,this._eye).normalize(),t*=this.rotateSpeed,W.setFromAxisAngle(Pt,t),this._eye.applyQuaternion(W),this.object.up.applyQuaternion(W),this._lastAxis.copy(Pt),this._lastAngle=t):!this.staticMoving&&this._lastAngle&&(this._lastAngle*=Math.sqrt(1-this.dynamicDampingFactor),this._eye.copy(this.object.position).sub(this.target),W.setFromAxisAngle(this._lastAxis,this._lastAngle),this._eye.applyQuaternion(W),this.object.up.applyQuaternion(W)),this._movePrev.copy(this._moveCurr)}_zoomCamera(){let t;this.state===S.TOUCH_ZOOM_PAN?(t=this._touchZoomDistanceStart/this._touchZoomDistanceEnd,this._touchZoomDistanceStart=this._touchZoomDistanceEnd,this.object.isPerspectiveCamera?this._eye.multiplyScalar(t):this.object.isOrthographicCamera?(this.object.zoom=Ht.clamp(this.object.zoom/t,this.minZoom,this.maxZoom),this._lastZoom!==this.object.zoom&&this.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")):(t=1+(this._zoomEnd.y-this._zoomStart.y)*this.zoomSpeed,t!==1&&t>0&&(this.object.isPerspectiveCamera?this._eye.multiplyScalar(t):this.object.isOrthographicCamera?(this.object.zoom=Ht.clamp(this.object.zoom/t,this.minZoom,this.maxZoom),this._lastZoom!==this.object.zoom&&this.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")),this.staticMoving?this._zoomStart.copy(this._zoomEnd):this._zoomStart.y+=(this._zoomEnd.y-this._zoomStart.y)*this.dynamicDampingFactor)}_getMouseOnScreen(t,e){return gt.set((t-this.screen.left)/this.screen.width,(e-this.screen.top)/this.screen.height),gt}_getMouseOnCircle(t,e){return gt.set((t-this.screen.width*.5-this.screen.left)/(this.screen.width*.5),(this.screen.height+2*(this.screen.top-e))/this.screen.width),gt}_addPointer(t){this._pointers.push(t)}_removePointer(t){delete this._pointerPositions[t.pointerId];for(let e=0;e<this._pointers.length;e++)if(this._pointers[e].pointerId==t.pointerId){this._pointers.splice(e,1);return}}_trackPointer(t){let e=this._pointerPositions[t.pointerId];e===void 0&&(e=new j,this._pointerPositions[t.pointerId]=e),e.set(t.pageX,t.pageY)}_getSecondPointerPosition(t){const e=t.pointerId===this._pointers[0].pointerId?this._pointers[1]:this._pointers[0];return this._pointerPositions[e.pointerId]}_checkDistances(){(!this.noZoom||!this.noPan)&&(this._eye.lengthSq()>this.maxDistance*this.maxDistance&&(this.object.position.addVectors(this.target,this._eye.setLength(this.maxDistance)),this._zoomStart.copy(this._zoomEnd)),this._eye.lengthSq()<this.minDistance*this.minDistance&&(this.object.position.addVectors(this.target,this._eye.setLength(this.minDistance)),this._zoomStart.copy(this._zoomEnd)))}}function io(i){this.enabled!==!1&&(this._pointers.length===0&&(this.domElement.setPointerCapture(i.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._addPointer(i),i.pointerType==="touch"?this._onTouchStart(i):this._onMouseDown(i))}function oo(i){this.enabled!==!1&&(i.pointerType==="touch"?this._onTouchMove(i):this._onMouseMove(i))}function no(i){this.enabled!==!1&&(i.pointerType==="touch"?this._onTouchEnd(i):this._onMouseUp(),this._removePointer(i),this._pointers.length===0&&(this.domElement.releasePointerCapture(i.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp)))}function so(i){this._removePointer(i)}function ro(){this.enabled!==!1&&(this.keyState=S.NONE,window.addEventListener("keydown",this._onKeyDown))}function ao(i){this.enabled!==!1&&(window.removeEventListener("keydown",this._onKeyDown),this.keyState===S.NONE&&(i.code===this.keys[S.ROTATE]&&!this.noRotate?this.keyState=S.ROTATE:i.code===this.keys[S.ZOOM]&&!this.noZoom?this.keyState=S.ZOOM:i.code===this.keys[S.PAN]&&!this.noPan&&(this.keyState=S.PAN)))}function co(i){let t;switch(i.button){case 0:t=this.mouseButtons.LEFT;break;case 1:t=this.mouseButtons.MIDDLE;break;case 2:t=this.mouseButtons.RIGHT;break;default:t=-1}switch(t){case Q.DOLLY:this.state=S.ZOOM;break;case Q.ROTATE:this.state=S.ROTATE;break;case Q.PAN:this.state=S.PAN;break;default:this.state=S.NONE}const e=this.keyState!==S.NONE?this.keyState:this.state;e===S.ROTATE&&!this.noRotate?(this._moveCurr.copy(this._getMouseOnCircle(i.pageX,i.pageY)),this._movePrev.copy(this._moveCurr)):e===S.ZOOM&&!this.noZoom?(this._zoomStart.copy(this._getMouseOnScreen(i.pageX,i.pageY)),this._zoomEnd.copy(this._zoomStart)):e===S.PAN&&!this.noPan&&(this._panStart.copy(this._getMouseOnScreen(i.pageX,i.pageY)),this._panEnd.copy(this._panStart)),this.dispatchEvent(Kt)}function lo(i){const t=this.keyState!==S.NONE?this.keyState:this.state;t===S.ROTATE&&!this.noRotate?(this._movePrev.copy(this._moveCurr),this._moveCurr.copy(this._getMouseOnCircle(i.pageX,i.pageY))):t===S.ZOOM&&!this.noZoom?this._zoomEnd.copy(this._getMouseOnScreen(i.pageX,i.pageY)):t===S.PAN&&!this.noPan&&this._panEnd.copy(this._getMouseOnScreen(i.pageX,i.pageY))}function ho(){this.state=S.NONE,this.dispatchEvent(Yt)}function fo(i){if(this.enabled!==!1&&this.noZoom!==!0){switch(i.preventDefault(),i.deltaMode){case 2:this._zoomStart.y-=i.deltaY*.025;break;case 1:this._zoomStart.y-=i.deltaY*.01;break;default:this._zoomStart.y-=i.deltaY*25e-5;break}this.dispatchEvent(Kt),this.dispatchEvent(Yt)}}function uo(i){this.enabled!==!1&&i.preventDefault()}function po(i){switch(this._trackPointer(i),this._pointers.length){case 1:this.state=S.TOUCH_ROTATE,this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX,this._pointers[0].pageY)),this._movePrev.copy(this._moveCurr);break;default:this.state=S.TOUCH_ZOOM_PAN;const t=this._pointers[0].pageX-this._pointers[1].pageX,e=this._pointers[0].pageY-this._pointers[1].pageY;this._touchZoomDistanceEnd=this._touchZoomDistanceStart=Math.sqrt(t*t+e*e);const n=(this._pointers[0].pageX+this._pointers[1].pageX)/2,o=(this._pointers[0].pageY+this._pointers[1].pageY)/2;this._panStart.copy(this._getMouseOnScreen(n,o)),this._panEnd.copy(this._panStart);break}this.dispatchEvent(Kt)}function go(i){switch(this._trackPointer(i),this._pointers.length){case 1:this._movePrev.copy(this._moveCurr),this._moveCurr.copy(this._getMouseOnCircle(i.pageX,i.pageY));break;default:const t=this._getSecondPointerPosition(i),e=i.pageX-t.x,n=i.pageY-t.y;this._touchZoomDistanceEnd=Math.sqrt(e*e+n*n);const o=(i.pageX+t.x)/2,s=(i.pageY+t.y)/2;this._panEnd.copy(this._getMouseOnScreen(o,s));break}}function yo(i){switch(this._pointers.length){case 0:this.state=S.NONE;break;case 1:this.state=S.TOUCH_ROTATE,this._moveCurr.copy(this._getMouseOnCircle(i.pageX,i.pageY)),this._movePrev.copy(this._moveCurr);break;case 2:this.state=S.TOUCH_ZOOM_PAN;for(let t=0;t<this._pointers.length;t++)if(this._pointers[t].pointerId!==i.pointerId){const e=this._pointerPositions[this._pointers[t].pointerId];this._moveCurr.copy(this._getMouseOnCircle(e.x,e.y)),this._movePrev.copy(this._moveCurr);break}break}this.dispatchEvent(Yt)}const mo=`//uniform 変数としてテクスチャのデータを受け取る
uniform sampler2D u_texture;
// vertexShaderで処理されて渡されるテクスチャ座標
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vUv;
varying mat4 vModelMatrix;
uniform vec3 uColor;
uniform vec3 uColor2;
uniform float uTime;
varying mat4 v_modelMatrix;
varying float v_fogDistance;

float edgeFactor(vec2 p){
    float thickness = 5.0;
    vec2 grid = abs(fract(p - 0.5) - 0.5) / fwidth(p) / thickness;
    return min(grid.x, grid.y);
}
void main(){

     float a = edgeFactor(vUv);

    //  フォッグの割合を計算 (線形補間)
    float fade = mod(uTime, 1.0); // u_timeを0〜1に正規化
    float fogFactor = smoothstep(0.0,300.0,  v_fogDistance);
    float fog_alpha = 1.0 - fogFactor; // フォッグが濃いほど透明に
    float coefficient = 1.2;
    float power = 1.0;
    vec3 glowColor = uColor;

    vec3 worldPosition = (vModelMatrix * vec4(vPosition, 1.0)).xyz;
    vec3 cameraToVertex = normalize(worldPosition - cameraPosition);
    float intensity = pow(coefficient + dot(cameraToVertex, normalize(vNormal)), power);

    // 等高線
    float contourInterval = 10.0; // 等高線の間隔
    float lineWidth = 1.0; // 等高線の線の幅
    float edgeWidth = 0.9; // 等高線の境界の幅（スムージング用）

    float t = uTime * 10.0;

    // 時間に基づいた変動を加えたY位置
    float yPos = vPosition.y - t;

    // 等高線の位置を計算
    float contourValue = mod(yPos, contourInterval);
    // 等高線のアルファ値を計算
    float alpha = smoothstep(lineWidth - edgeWidth, lineWidth, contourValue) - smoothstep(lineWidth, lineWidth + edgeWidth, contourValue);

    // 等高線の色
    vec3 contourColor = uColor2; // 赤色

    // 地形の色
    vec3 terrainColor = uColor; // グレー色

    // 等高線か地形かによって色を決定
    vec3 color = mix(terrainColor, contourColor, alpha);

    vec3 color2 = mix(color, glowColor, 0.5);


    // gl_FragColor = vec4(color, fog_alpha - 1.0)  * intensity;
    gl_FragColor = vec4(color, fog_alpha)  * intensity;
    // gl_FragColor = vec4(color, a);
    // gl_FragColor = vec4(vec2(vUv), 0.0, 1.0);

}`,xo=`varying vec2 vUv;// fragmentShaderに渡すためのvarying変数
varying vec3 vPosition;
uniform float uTime;
varying vec3 vNormal;
varying mat4 vModelMatrix;
varying mat4 v_modelMatrix;
varying float v_fogDistance;

layout(location = 0) in vec3 aPos; // 頂点の位置

void main() {
    vUv = uv;
    vPosition = position;
    vNormal = normal;
    vModelMatrix = modelMatrix;
    // ワールド座標を計算
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    v_modelMatrix = modelMatrix;

    // 中心 (0, 0, 0) からの距離を計算
    v_fogDistance = length(worldPosition.xyz);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`;var _o=Te(`<div class="app relative flex h-screen w-screen"><canvas class="h-screen w-full bg-black"></canvas> <div class="pointer-events-none absolute left-0 top-0 z-10 h-full w-full"><div class="flex h-full w-full flex-col items-center justify-center"><span class="text-[30px] font-bold text-white [text-shadow:_0px_0px_10px_#000]">ENSHURIN MAP VIEW</span> <button class="pointer-events-auto text-[30px] font-bold text-white">Let's take a look at the map.</button></div></div></div>`);function Do(i,t){Se(t,!0);const e=async g=>{const b=await(await fetch(g)).arrayBuffer(),v=await(await Ji(b)).getImage(),w=(await v.readRasters())[0],I=v.getWidth(),U=v.getHeight();return{data:w,width:I,height:U}};let n=De(null),o,s,a,r;const c={uTime:{value:0},uTexture:{value:new Ue().load("./microtopographic.webp")},uColor:{value:new qt("rgb(252, 252, 252)")},uColor2:{value:new qt("rgb(0, 194, 36)")}},l=new Fe({uniforms:c,vertexShader:xo,fragmentShader:mo,transparent:!0}),f=async()=>{const g=await e("./ensyurin_dem.tiff"),E=1,b=1,_=g.width,v=g.height,D=new Float32Array(g.data.map(F=>F*.15)),w=new je,I=_*E/2,U=v*b/2;D.reduce((F,P)=>Math.min(F,P),1/0);const k=Array.from({length:_*v},(F,P)=>{const K=Math.floor(P/_);return[P%_*E-I,D[P],K*b-U]}).flat(),O=new Float32Array(k);w.setAttribute("position",new $t(O,3));const ct=Array.from({length:_*v},(F,P)=>{const K=Math.floor(P/_),Y=P%_/(_-1),Z=K/(v-1);return[Y,Z]}).flat(),wt=Array.from({length:(v-1)*(_-1)},(F,P)=>{const K=Math.floor(P/(_-1)),ot=P%(_-1),Y=K*_+ot,Z=Y+_,ft=Y+1,X=Z+1;return[Y,Z,ft,Z,X,ft]}).flat(),z=new Float32Array(ct);w.setAttribute("uv",new $t(z,2)),w.setIndex(wt),new Be({color:5596842});const lt=new Ve(w,l),ht=o.getObjectByName("dem");ht&&o.remove(ht),lt.name="dem",w.computeVertexNormals();const it=new ze().makeRotationY(Math.PI/-2);w.applyMatrix4(it),o.add(lt)};let h=!1;const y=g=>{r.autoRotate=g,h=!h;const b=180*Math.PI/180,_=180;s.position.x=_*Math.sin(b),s.position.z=_*Math.cos(b);const v={position:s.position.clone(),lookAt:{x:0,y:0,z:0}},D={position:{x:_*Math.cos(b),y:600,z:0},lookAt:{x:0,y:0,z:0}};if(h){v.position=s.position.clone();const O=r.target;v.lookAt={x:O.x,y:O.y,z:O.z}}else{D.position=s.position.clone();const O=r.target;D.lookAt={x:O.x,y:O.y,z:O.z}}const w=h?D:v,I=pt.to(s.position,{x:w.position.x,y:w.position.y,z:w.position.z,duration:1,ease:"power1",onUpdate:()=>{s.up.set(0,1,0),s.lookAt(w.lookAt.x,w.lookAt.y,w.lookAt.z)}}),U=pt.to(r.target,{x:w.lookAt.x,y:w.lookAt.y,z:w.lookAt.z,duration:1,ease:"power1",onUpdate:()=>{s.lookAt(r.target.x,r.target.y,r.target.z)}}),k=pt.to(s,{fov:h?45:75,duration:1,ease:"power1",onUpdate:()=>{s.updateProjectionMatrix()}});pt.timeline({onComplete:()=>{h&&(window.location.href="/map")}}).add(I).add(U,"-=1.0").add(k,"-=1.0")};Ae(async()=>{if(!q(n))return;o=new ke,s=new Ne(75,window.innerWidth/window.innerHeight,.1,1e5);const E=-40*Math.PI/180,b=180;s.position.x=b*Math.sin(E),s.position.z=b*Math.cos(E),s.position.y=100,o.add(s);const _=q(n).getContext("webgl2");r=new Re(s,q(n)),r.enableDamping=!0,r.enablePan=!1,r.enableZoom=!1,r.autoRotateSpeed=1,r.autoRotate=!0;const v=new eo(s,q(n));v.noPan=!0,v.noRotate=!0,v.zoomSpeed=.2,a=new Ge({canvas:q(n),context:_,alpha:!0}),a.setSize(window.innerWidth,window.innerHeight),a.setPixelRatio(Math.min(window.devicePixelRatio,2)),f();const D=new Le,w=()=>{requestAnimationFrame(w),r.update(),v.update(),c.uTime.value=D.getElapsedTime(),a.render(o,s)};w();const I=()=>{const U=window.innerWidth,k=window.innerHeight;a.setPixelRatio(window.devicePixelRatio),a.setSize(U,k),s.aspect=U/k,s.updateProjectionMatrix()};window.addEventListener("resize",I)});var u=_o(),p=bt(u);Oe(p,g=>Me(n,g),()=>q(n));var m=Xt(p,2),d=bt(m),T=Xt(bt(d),2);T.__click=()=>y(h),vt(d),vt(m),vt(u),Ee(i,u),Pe()}ve(["click"]);export{Ao as L,Do as _,Po as a};
